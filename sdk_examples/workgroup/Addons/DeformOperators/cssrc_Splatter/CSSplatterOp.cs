// CSSplatterPlugin
// Initial code generated by Softimage SDK Wizard
// Executed Tue Sep 26 10:04:39 EDT 2006 by mbelzile
// 
// This examples shows how to build a deform operator with C#
//
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
//
//	Copyright 2008 Autodesk, Inc.  All rights reserved.  
//	Use of this software is subject to the terms of the Autodesk license agreement 
//	provided at the time of installation or download, or which otherwise accompanies 
//	this software in either electronic or hard copy form.   

using System;
using Softimage.XSIOM; // Softimage object model
using Softimage.XSIUtil;

//
// XSIPlugin class implementation. This class is mandatory and is used to 
// register the splatter operator and its menu.
//
public class XSIPlugin : Base
{
	public bool Load(PluginRegistrar in_reg)
	{
		in_reg.Author = "Softimage Corp.";
		in_reg.Name = "C# Splatter Plugin";
		in_reg.URL = "www.softimage.com";
		in_reg.Major = 1;
		in_reg.Minor = 0;

		in_reg.RegisterOperator("CSSplatterOp");
		in_reg.RegisterMenu(siMenuAnchorPoints.siMenuMainTopLevelID,
								"CSSplatterOp_Menu",
								false, /* submenu */
								true /*dynamic*/);
		return true;
	}
}

//
// CSSplatter operator implementation. 
// Note: The name of the implementation class must be 
// the same as the plug-in item custom operator i.e. CSSplatter
//

public class CSSplatterOp : Base
{
	// Define the CSSplatterOp SquishFactor parameter
	public bool Define( Context in_ctxt )
	{		
		CustomOperator oCustomOperator = (CustomOperator)in_ctxt.Source;
		ParamDef oPDef = GetFactory().CreateParamDef(	"SquishFactor", 
														siVariantType.siDouble, 
														siParamClassification.siClassifUnknown, 
														(int)siCapabilities.siPersistable, 
														"", "", 0.5, 0, 1, 0, 1);
		oCustomOperator.AddParameter(oPDef);

		oCustomOperator.AlwaysEvaluate = false;
		oCustomOperator.Debug = 0;
		return true;
	}

	public bool Update( Context in_ctxt )
	{
		OperatorContext ctxt = (OperatorContext)in_ctxt;

		// Get the squish factor.
		double dSquishFactor = (double)ctxt.GetParameterValue("SquishFactor");

		///////////////////////////////////////////////////////////////
		// Inputs
		///////////////////////////////////////////////////////////////
		// Get the array of point positions. 
		Primitive inPrim = (Primitive)ctxt.GetInputValue(0, null, 0);
		Geometry inGeom = inPrim.GetGeometry(0, siConstructionMode.siConstructionModeSecondaryShape);

		// Returns a 2 dimension array (3xN)
		Array posArray = (Array)inGeom.Points.PositionArray;

		// Get the object's global Y position.(ORIGINAL)
		double dGPosYObj = (double)ctxt.GetInputValue(1, null, 0);

		///////////////////////////////////////////////////////////////
		// Splat!
		///////////////////////////////////////////////////////////////
		for (int i = 0; i < posArray.GetLength(1); i++)
		{
			// Compute the point's global Y position.
			double dGPosYPnt = (double)posArray.GetValue(1, i) + dGPosYObj;

			// If the point is below the Y=0 plane...
			if (dGPosYPnt < 0)
			{
				// Compute the squish factor for the point.
				double dSquishPnt = 1.0 - dGPosYPnt * dSquishFactor;

				// Squish the point.
				posArray.SetValue((double)posArray.GetValue(0, i) * dSquishPnt, 0, i);
				posArray.SetValue(dGPosYObj * -1, 1, i);
				posArray.SetValue((double)posArray.GetValue(2, i) * dSquishPnt, 2, i);
			}
		}

		///////////////////////////////////////////////////////////////
		// Output
		///////////////////////////////////////////////////////////////

		// Update the object's point position
		Primitive outPrim = (Primitive)ctxt.OutputTarget;
		Geometry outGeom = outPrim.GetGeometry(0, siConstructionMode.siConstructionModeSecondaryShape);

		outGeom.Points.PositionArray = posArray;

		return true;
	}

	public bool DefineLayout( Context in_ctxt )
	{
		PPGLayout oLayout = (PPGLayout)in_ctxt.Source;
		oLayout.Clear();
		oLayout.AddItem("SquishFactor",null,null);
		return true;
	}
}


//
// CSSplatterOp_Menu implementation. We use a menu to apply the CSSplatterOp from the UI.
// Note: The name of the implementation class must be 
// the same as the plug-in item menu i.e. CSSplatterOp_Menu
//

public class CSSplatterOp_Menu : Base
{
	public bool Init(Context in_ctxt)
	{
		Menu menu = (Menu)in_ctxt.Source;

		// Create the menu item
		menu.AddCallbackItem("Demo", "ApplySplatterMenu");	

		return true;
	}

	public bool ApplySplatterMenu(Context in_ctxt)
	{
		try
		{
			XSICollection inputs = (XSICollection)GetFactory().CreateObject("XSI.Collection");
			
			// Create the deformee
			X3DObject cylinder = GetXSI().ActiveSceneRoot.AddGeometry("Cylinder", "NurbsSurface", "Cylinder");

			// Because this is a deform it is critical that we have both 
			// input and output connections to this Primitive
			// This will be an input/output connection
			inputs.Add(cylinder.ActivePrimitive);

			// This will be an input connection		
			Parameter posy = cylinder.Kinematics.Global.Parameters["posy"];
			inputs.Add(posy);

			// Connect the op output to the X3DObject active primitive
			cylinder.ActivePrimitive.AddCustomOp(	"CSSplatterOp",
													inputs,
													null,
													siConstructionMode.siConstructionModeDefault);
		}
		catch (Exception e)
		{
			Error("Error while connecting CSSplatterOp: " + e.ToString());
		}

		return true;
	}
}

// 
// This sample class is used to demonstrate how a base class can be used to implement plug-in items.
// 

public class Base
{
	CXSIApplicationClass m_xsi;
	CXSIFactoryClass m_fact;

	protected Base()
	{
		m_xsi = new CXSIApplicationClass();
		m_fact = new CXSIFactoryClass();
	}
	protected bool Log(String str)
	{
		m_xsi.LogMessage(str, siSeverity.siVerbose);
		return true;
	}

	protected bool Info(String str)
	{
		m_xsi.LogMessage(str, siSeverity.siInfo);
		return true;
	}

	protected bool Error(String str)
	{
		m_xsi.LogMessage(str, siSeverity.siError);
		return true;
	}

	protected XSIApplication GetXSI()
	{
		return m_xsi;
	}

	protected XSIFactory GetFactory()
	{
		return m_fact;
	}
}
