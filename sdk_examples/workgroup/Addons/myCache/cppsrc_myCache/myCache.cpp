// myCache Plug-in
// Initial code generated by Softimage SDK Wizard
// Executed Thu Nov 15 06:42:18 EST 2007 by hmathee
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
//
//	Copyright 2008 Autodesk, Inc.  All rights reserved.  
//	Use of this software is subject to the terms of the Autodesk license agreement 
//	provided at the time of installation or download, or which otherwise accompanies 
//	this software in either electronic or hard copy form.   

#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>
#include <xsi_primitive.h>
#include <xsi_geometry.h>
#include <xsi_iceattribute.h>
#include <xsi_iceattributedataarray.h>

#include <stdio.h>

using namespace XSI; 
using namespace MATH;

const ULONG k_nChunkSize = 1000;

XSIPLUGINCALLBACK CStatus XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"belzilm");
	in_reg.PutName(L"myCache Plug-in");

	in_reg.PutVersion(1,0);
	in_reg.RegisterConverterEvent(L"myCacheExportEvent",siOnCustomFileExport,L"myCache");
	//RegistrationInsertionPoint - do not remove this line

	return CStatus::OK;
}

// Template for exporting attribute values.
template < class T >
class CICEAttributeDataHelper
{
    public:
    static void Export( ICEAttribute& in_attr, FILE* in_pFile )
    {
        Application().LogMessage( L"Function for exporting this attribute type is missing: " + in_attr.GetFullName() );
    }
};

// Specific template instantiation for exporting vector3 attribute values.
template < >
class CICEAttributeDataHelper<CVector3f>
{
    public:
    static void Export( ICEAttribute& in_attr, FILE* in_pFile )
    {
		// get the number of elements in this cache file
		ULONG nElementCount = in_attr.GetElementCount();
		fwrite( &nElementCount, sizeof(ULONG), 1, in_pFile);

		ULONG nByteCount = sizeof(float)*3;
		fwrite( &nByteCount, sizeof(ULONG), 1, in_pFile);
		
		// read the data in chunks of 1000 elements
		for(ULONG i=0; i<nElementCount; i+=k_nChunkSize)
		{
			CICEAttributeDataArray<CVector3f> data;
			in_attr.GetDataArrayChunk(i, k_nChunkSize, data);

			ULONG nUpperlimit = nElementCount-i <k_nChunkSize ? nElementCount : k_nChunkSize;
			
			for(ULONG j=0; j<nUpperlimit; j++)
			{
				// retrieve one vector
				float f[3];
				data[j].Get(f[0],f[1],f[2]);

				// write out that vector
				fwrite( &f, sizeof(float), 3, in_pFile );				
				//Application().LogMessage( CString(f[0]) +" "+ CString(f[1]) +" "+ CString(f[2]) );
			}
		}
    }
};

template < >
class CICEAttributeDataHelper<CColor4f>
{
    public:
    static void Export( ICEAttribute& in_attr, FILE* in_pFile )
    {
		// get the number of elements in this cache file
		ULONG nElementCount = in_attr.GetElementCount();
		fwrite( &nElementCount, sizeof(ULONG), 1, in_pFile);

		ULONG nByteCount = sizeof(float)*4;
		fwrite( &nByteCount, sizeof(ULONG), 1, in_pFile);
		
		// read the data in chunks of 1000 elements
		for(ULONG i=0; i<nElementCount; i+=k_nChunkSize)
		{
			CICEAttributeDataArray<CColor4f> data;
			in_attr.GetDataArrayChunk(i, k_nChunkSize, data);

			ULONG nUpperlimit = nElementCount-i <k_nChunkSize ? nElementCount : k_nChunkSize;
			
			for(ULONG j=0; j<nUpperlimit; j++)
			{
				// Write out one color
				float f[4];
				data[j].GetAsRGBA(f[0],f[1],f[2],f[3]);

				fwrite( &f, sizeof(float), 4, in_pFile );				
				//Application().LogMessage( CString("Color: ") + CString(f[0]) +" "+ CString(f[1]) +" "+ CString(f[2]) +" "+ CString(f[3]) );
			}
		}
    }
};

template < >
class CICEAttributeDataHelper<float>
{
    public:
    static void Export( ICEAttribute& in_attr, FILE* in_pFile )
    {
		// get the number of elements in this cache file
		ULONG nElementCount = in_attr.GetElementCount();
		fwrite( &nElementCount, sizeof(ULONG), 1, in_pFile);
		
		ULONG nByteCount = sizeof(float);
		fwrite( &nByteCount, sizeof(ULONG), 1, in_pFile);
		
		// read the data in chunks of 1000 elements
		for(ULONG i=0; i<nElementCount; i+=k_nChunkSize)
		{
			CICEAttributeDataArray<float> data;
			in_attr.GetDataArrayChunk(i, k_nChunkSize, data);

			ULONG nUpperlimit = nElementCount-i <k_nChunkSize ? nElementCount : k_nChunkSize;
			
			for(ULONG j=0; j<nUpperlimit; j++)
			{
				float f = data[j];
				fwrite( &f, sizeof(float), 1, in_pFile );
				//Application().LogMessage( CString(f) );
			}
		}
    }
};

// Callback for the myCacheExportEvent event.
// The attribute data format used by the mycache event has the following layout:
//
// [number of attributes saved]
// [attribute name character count][attribute name]
// [number of elements][byte count per element]
// [element data block ]

XSIPLUGINCALLBACK CStatus myCacheExportEvent_OnEvent( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Application().LogMessage(L"myCacheExportEvent_OnEvent called",siVerboseMsg);
	Application().LogMessage(L"Target: " + CString(ctxt.GetAttribute(L"Target")),siVerboseMsg);
	Application().LogMessage(L"FileName: " + CString(ctxt.GetAttribute(L"FileName")),siVerboseMsg);
	Application().LogMessage(L"Attributes: " + CString(ctxt.GetAttribute(L"UserData")),siVerboseMsg);
	Application().LogMessage(L"Frame: " + CString(ctxt.GetAttribute(L"Frame")),siVerboseMsg);

	// open the file
	FILE * pFile = fopen(CString(ctxt.GetAttribute(L"FileName")).GetAsciiString(),"wb");
	if (!pFile)
	{
		return CStatus::False;
	}

	// Loop over the attributes selected in the cache options dialog.
	// note: Attributes are stored in the user data. 
	CStringArray strAttribArray = CString( ctxt.GetAttribute(L"UserData") ).Split( "," );

	// Retrieve the target geometry at the current frame
	CValue frame = ctxt.GetAttribute(L"Frame");	
	Geometry geo = Primitive( ctxt.GetAttribute(L"Target") ).GetGeometry( frame );

	ULONG nAttribCount = strAttribArray.GetCount( );
	fwrite( &nAttribCount, sizeof(ULONG), 1, pFile);
	
	for ( LONG i=0; i<strAttribArray.GetCount( ); i++ )
	{
		ICEAttribute attr = geo.GetICEAttributeFromName( strAttribArray[i] );
		
		if ( attr.IsDefined() )
		{
			CString strAttrib( strAttribArray[i] );
			
			Application().LogMessage(L"Caching attribute: " + strAttribArray[i], siVerboseMsg);
			
			// save attrib name
			ULONG nCharCount = strAttrib.Length();
			fwrite( &nCharCount, sizeof(ULONG), 1, pFile);
			fwrite( strAttrib.GetAsciiString(), sizeof(char), nCharCount, pFile);

			switch( attr.GetDataType() )
			{
				case XSI::siICENodeDataFloat:		CICEAttributeDataHelper<float>::Export( attr, pFile ); break;
				case XSI::siICENodeDataLong:		CICEAttributeDataHelper<LONG>::Export( attr, pFile ); break;
				case XSI::siICENodeDataBool:		CICEAttributeDataHelper<bool>::Export( attr, pFile ); break;
				case XSI::siICENodeDataVector2:		CICEAttributeDataHelper<XSI::MATH::CVector2f>::Export( attr, pFile ); break;
				case XSI::siICENodeDataVector3:		CICEAttributeDataHelper<XSI::MATH::CVector3f>::Export( attr, pFile ); break;
				case XSI::siICENodeDataVector4:		CICEAttributeDataHelper<XSI::MATH::CVector4f>::Export( attr, pFile ); break;
				case XSI::siICENodeDataQuaternion:	CICEAttributeDataHelper<XSI::MATH::CQuaternionf>::Export( attr, pFile ); break;
				case XSI::siICENodeDataRotation:	CICEAttributeDataHelper<XSI::MATH::CRotationf>::Export( attr, pFile ); break;
				case XSI::siICENodeDataMatrix33:	CICEAttributeDataHelper<XSI::MATH::CMatrix3f>::Export( attr, pFile ); break;
				case XSI::siICENodeDataMatrix44:	CICEAttributeDataHelper<XSI::MATH::CMatrix4f>::Export( attr, pFile ); break;
				case XSI::siICENodeDataColor4:		CICEAttributeDataHelper<XSI::MATH::CColor4f>::Export( attr, pFile ); break;
			};
		}
	}
	
	// close the file stream again
	fclose(pFile);

// 	Return value is ignored as this event can not be aborted.
	return CStatus::OK;
}

