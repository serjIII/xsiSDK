// PDC_Exporter Plug-in
// Initial code generated by Softimage SDK Wizard
// Executed Tue Nov 27 10:49:11 EST 2007 by hmathee
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
// 
// For a file format description please refer to:
// http://visservices.sdsc.edu/software/maya/utils/pdc.php
//
// For a reference of the maya particle attributes refer to:
// http://caad.arch.ethz.ch/info/maya/manual/UserGuide/Express/ExpressParticle.fm8.html#178734
//
//
//	Copyright 2008 Autodesk, Inc.  All rights reserved.  
//	Use of this software is subject to the terms of the Autodesk license agreement 
//	provided at the time of installation or download, or which otherwise accompanies 
//	this software in either electronic or hard copy form.   

#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>
#include <xsi_primitive.h>
#include <xsi_geometry.h>
#include <xsi_iceattribute.h>
#include <xsi_iceattributedataarray.h>
#include <stdio.h>
using namespace XSI; 
using namespace MATH;

const ULONG g_ulChunksize = 1000;

XSIPLUGINCALLBACK CStatus XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"hmathee");
	in_reg.PutName(L"PDC_Exporter Plug-in");
	in_reg.PutEmail(L"");
	in_reg.PutURL(L"");
	in_reg.PutVersion(1,0);
	in_reg.RegisterConverterEvent(L"siOnPDCExport",siOnCustomFileExport,L"PDC");
	//RegistrationInsertionPoint - do not remove this line

	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
	CString strPluginName;
	strPluginName = in_reg.GetName();
	Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
	return CStatus::OK;
}

// a helper function to switch the byte order for an integer
int INT_little_endian_TO_big_endian(int i)
{
    return((i&0xff)<<24)+((i&0xff00)<<8)+((i&0xff0000)>>8)+((i>>24)&0xff);
}

// a helper function to swith the byte order for a double
double DOUBLE_little_endian_TO_big_endian(double i)
{
	double result;
	for(int l=0;l<8;l++)
	{
		((char *)&result)[l] = ((char*)&i)[7-l];
	}
	return result;
}

// a helper function to determine if a MD attibute is defined
bool AttributeIsDefined(CRefArray in_attributes,CString in_name)
{
	for(long i=0;i<in_attributes.GetCount();i++)
	{
		if(ICEAttribute(in_attributes[i]).GetName().IsEqualNoCase(in_name))
			return true;
	}

	return false;
}

// Callback for the siOnPDCExport event.
XSIPLUGINCALLBACK CStatus siOnPDCExport_OnEvent( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Application().LogMessage(L"siOnPDCExport_OnEvent called",siVerboseMsg);

	Application().LogMessage(L"Target: " + CString(ctxt.GetAttribute(L"Target")),siVerboseMsg);

	Application().LogMessage(L"FileName: " + CString(ctxt.GetAttribute(L"FileName")),siVerboseMsg);

	Application().LogMessage(L"Frame: " + CValue(ctxt.GetAttribute(L"Frame")).GetAsText(),siVerboseMsg);

	// force the frame to be LONG, we can't allow sub frames here.
	LONG l_lFrame = CValue(ctxt.GetAttribute(L"Frame"));

	// retrieve the geometry from the context
	Geometry geo = Primitive(CRef(ctxt.GetAttribute(L"Target"))).GetGeometry( (double)l_lFrame );

	// retrieve the first attribute, in this case we are looking at the point position!
	ICEAttribute attr = geo.GetICEAttributeFromName(L"PointPosition");

	// maya increases the frame by 250, so we need to remap the frame number from 1 to 250 
	// respectively 2 to 500 etc.
	CString l_csFileName = CString(ctxt.GetAttribute(L"FileName"));
	for(LONG i = l_csFileName.Length()-6;i>=0;i--)
	{
		if( l_csFileName[i] == '.' || l_csFileName[i] == '_' )
		{
			// rebuild the filename based on the delimiter positions
			CString l_csNewFileName;
			for(LONG j=0;j<=i;j++)
			{
				l_csNewFileName += l_csFileName[j];
			}
			l_csNewFileName += CValue(l_lFrame*250).GetAsText() + L".PDC";
			l_csFileName = l_csNewFileName;
			break;
		}
	}

	// open the file
	FILE * file = fopen(l_csFileName.GetAsciiString(),"wb");
	
	if (NULL != file)
	{
		// --------------------------------------------------------
		// write the PDC header -----------------------------------
		// --------------------------------------------------------
		fwrite("PDC ",1,4,file);
	
		int l_iTemp = INT_little_endian_TO_big_endian(int(1));
		// write the PDC version
		fwrite(&l_iTemp,4,1,file);
		// write BIG_ENDIAN value storage type
		fwrite(&l_iTemp,4,1,file);
		// write two integers (undocumented use)
		l_iTemp = 0;
		fwrite(&l_iTemp,4,1,file);
		fwrite(&l_iTemp,4,1,file);
		// write the number of particles!
		ULONG l_ulNbParticles = attr.GetElementCount();
		l_iTemp = INT_little_endian_TO_big_endian((int)l_ulNbParticles);
		fwrite(&l_iTemp,4,1,file);
		// write count of attributes ( we will overwrite this part later,
		// depending on how many attributes we stored!)
		l_iTemp = INT_little_endian_TO_big_endian(int(1));
		fwrite(&l_iTemp,4,1,file);
	
		int l_iAttributesWritten=0;
		CRefArray l_refAttributes = geo.GetICEAttributes();
	
		// --------------------------------------------------------
		// now let's write the age
		// --------------------------------------------------------
		if(AttributeIsDefined(l_refAttributes,L"age"))
		{
			attr = geo.GetICEAttributeFromName(L"age");
	
			// also check if the attribute contains any data...
			CICEAttributeDataArray<float> l_vTestData;
			attr.GetDataArrayChunk(0,1,l_vTestData);
			if(l_vTestData.GetCount()>0)
			{
				l_iAttributesWritten++;
	
				// write the length of the name of the attribute's name
				l_iTemp = INT_little_endian_TO_big_endian(int(3));
				fwrite(&l_iTemp,4,1,file);
				// write out the name of the attribute!
				fwrite("age",1,3,file);
	
				// write the datatype of the particle attribute
				// in this case it is 3 for double array
				l_iTemp = INT_little_endian_TO_big_endian(int(3));
				fwrite(&l_iTemp,4,1,file);
	
				if(attr.IsConstant())
				{
					CICEAttributeDataArray<float> l_vData;
					attr.GetDataArrayChunk(0,1,l_vData);
					double l_dTemp = DOUBLE_little_endian_TO_big_endian((double)l_vData[0]);
					for(ULONG i=0;i<l_ulNbParticles;i++)
						fwrite(&l_dTemp,8,1,file);
				}
				else
				{
					// read the data in chunks of 1000 elements
					for(ULONG i=0;i<l_ulNbParticles;i+=g_ulChunksize)
					{
						CICEAttributeDataArray<float> l_vData;
						ULONG l_ulUpperlimit = l_ulNbParticles-i<g_ulChunksize ? l_ulNbParticles-i : g_ulChunksize;
	
						attr.GetDataArrayChunk(i,l_ulUpperlimit,l_vData);
						for(ULONG j=0;j<l_ulUpperlimit;j++)
						{
							// retrieve one float and convert to double
							double l_dTemp = DOUBLE_little_endian_TO_big_endian((double)l_vData[j]);
	
							// write out that double
							fwrite(&l_dTemp,8,1,file);
						}
					}
				}
			}
		}
	
		// --------------------------------------------------------
		// now let's write the particleId
		// --------------------------------------------------------
		{
			l_iAttributesWritten++;
	
			// write the length of the name of the attribute's name
			l_iTemp = INT_little_endian_TO_big_endian(int(10));
			fwrite(&l_iTemp,4,1,file);
			// write out the name of the attribute!
			fwrite("particleId",1,10,file);
	
			// write the datatype of the particle attribute
			// in this case it is 3 for double array
			l_iTemp = INT_little_endian_TO_big_endian(int(3));
			fwrite(&l_iTemp,4,1,file);
	
			// write out as many particleIds as we need!
			double l_dData;
			for(ULONG i=0;i<l_ulNbParticles;i++)
			{
				l_dData = DOUBLE_little_endian_TO_big_endian((double)i);
				fwrite(&l_dData,8,1,file);
			}
		}
	
		// --------------------------------------------------------
		// now let's write the mass
		// --------------------------------------------------------
		if(AttributeIsDefined(l_refAttributes,L"mass"))
		{
			attr = geo.GetICEAttributeFromName(L"mass");
	
			// also check if the attribute contains any data...
			CICEAttributeDataArray<float> l_vTestData;
			attr.GetDataArrayChunk(0,1,l_vTestData);
			if(l_vTestData.GetCount()>0)
			{
				l_iAttributesWritten++;
	
				// write the length of the name of the attribute's name
				l_iTemp = INT_little_endian_TO_big_endian(int(4));
				fwrite(&l_iTemp,4,1,file);
				// write out the name of the attribute!
				fwrite("mass",1,4,file);
	
				// write the datatype of the particle attribute
				// in this case it is 3 for double array
				l_iTemp = INT_little_endian_TO_big_endian(int(3));
				fwrite(&l_iTemp,4,1,file);
	
				if(attr.IsConstant())
				{
					CICEAttributeDataArray<float> l_vData;
					attr.GetDataArrayChunk(0,1,l_vData);
					double l_dTemp = DOUBLE_little_endian_TO_big_endian((double)l_vData[0]);
					for(ULONG i=0;i<l_ulNbParticles;i++)
						fwrite(&l_dTemp,8,1,file);
				}
				else
				{
					// read the data in chunks of 1000 elements
					for(ULONG i=0;i<l_ulNbParticles;i+=g_ulChunksize)
					{
						CICEAttributeDataArray<float> l_vData;
						ULONG l_ulUpperlimit = l_ulNbParticles-i<g_ulChunksize ? l_ulNbParticles-i : g_ulChunksize;
	
						attr.GetDataArrayChunk(i,l_ulUpperlimit,l_vData);
						for(ULONG j=0;j<l_ulUpperlimit;j++)
						{
							// retrieve one float and convert to double
							double l_dTemp = DOUBLE_little_endian_TO_big_endian((double)l_vData[j]);
	
							// write out that double
							fwrite(&l_dTemp,8,1,file);
						}
					}
				}
			}
		}
	
		// --------------------------------------------------------
		// now let's write the pointposition!
		// --------------------------------------------------------
		if(AttributeIsDefined(l_refAttributes,L"PointPosition"))
		{
			attr = geo.GetICEAttributeFromName(L"PointPosition");
	
			// also check if the attribute contains any data...
			CICEAttributeDataArray<CVector3f> l_vTestData;
			attr.GetDataArrayChunk(0,1,l_vTestData);
			if(l_vTestData.GetCount()>0)
			{
				l_iAttributesWritten++;
	
				// write the length of the name of the attribute's name
				l_iTemp = INT_little_endian_TO_big_endian(int(8));
				fwrite(&l_iTemp,4,1,file);
				// write out the name of the attribute!
				fwrite("position",1,8,file);
	
				// write the datatype of the particle attribute
				// in this case it is 5 for vector array
				l_iTemp = INT_little_endian_TO_big_endian(int(5));
				fwrite(&l_iTemp,4,1,file);
	
				// read the data in chunks of 1000 elements
				for(ULONG i=0;i<l_ulNbParticles;i+=g_ulChunksize)
				{
					CICEAttributeDataArray<CVector3f> l_vData;
					ULONG l_ulUpperlimit = l_ulNbParticles-i<g_ulChunksize ? l_ulNbParticles-i : g_ulChunksize;
	
					attr.GetDataArrayChunk(i,l_ulUpperlimit,l_vData);
					for(ULONG j=0;j<l_ulUpperlimit;j++)
					{
						// retrieve one vector
						float l_fTemp[3];
						l_vData[j].Get(l_fTemp[0],l_fTemp[1],l_fTemp[2]);
	
						// convert to double
						double l_dTemp[3];
						l_dTemp[0] = DOUBLE_little_endian_TO_big_endian((double)l_fTemp[0]);
						l_dTemp[1] = DOUBLE_little_endian_TO_big_endian((double)l_fTemp[1]);
						l_dTemp[2] = DOUBLE_little_endian_TO_big_endian((double)l_fTemp[2]);
	
						// write out that vector
						fwrite(&l_dTemp,8,3,file);
					}
				}
			}
		}
	
		// --------------------------------------------------------
		// now let's write the pointvelocity!
		// --------------------------------------------------------
		if(AttributeIsDefined(l_refAttributes,L"PointVelocity"))
		{
			attr = geo.GetICEAttributeFromName(L"PointVelocity");
	
			// also check if the attribute contains any data...
			CICEAttributeDataArray<CVector3f> l_vTestData;
			attr.GetDataArrayChunk(0,1,l_vTestData);
			if(l_vTestData.GetCount()>0)
			{
				l_iAttributesWritten++;
	
				// write the length of the name of the attribute's name
				l_iTemp = INT_little_endian_TO_big_endian(int(8));
				fwrite(&l_iTemp,4,1,file);
				// write out the name of the attribute!
				fwrite("velocity",1,8,file);
	
				// write the datatype of the particle attribute
				// in this case it is 5 for vector array
				l_iTemp = INT_little_endian_TO_big_endian(int(5));
				fwrite(&l_iTemp,4,1,file);
	
				if(attr.IsConstant())
				{
					CICEAttributeDataArray<CVector3f> l_vData;
					attr.GetDataArrayChunk(0,1,l_vData);
					// retrieve one vector
					float l_fTemp[3];
					l_vData[0].Get(l_fTemp[0],l_fTemp[1],l_fTemp[2]);
	
					// convert to double
					double l_dTemp[3];
					l_dTemp[0] = DOUBLE_little_endian_TO_big_endian((double)l_fTemp[0]);
					l_dTemp[1] = DOUBLE_little_endian_TO_big_endian((double)l_fTemp[1]);
					l_dTemp[2] = DOUBLE_little_endian_TO_big_endian((double)l_fTemp[2]);
					for(ULONG i=0;i<l_ulNbParticles;i++)
						fwrite(&l_dTemp,8,3,file);
				}
				else
				{
					// read the data in chunks of 1000 elements
					for(ULONG i=0;i<l_ulNbParticles;i+=g_ulChunksize)
					{
						CICEAttributeDataArray<CVector3f> l_vData;
						ULONG l_ulUpperlimit = l_ulNbParticles-i<g_ulChunksize ? l_ulNbParticles-i : g_ulChunksize;
	
						attr.GetDataArrayChunk(i,l_ulUpperlimit,l_vData);
						for(ULONG j=0;j<l_ulUpperlimit;j++)
						{
							// retrieve one vector
							float l_fTemp[3];
							l_vData[j].Get(l_fTemp[0],l_fTemp[1],l_fTemp[2]);
	
							// convert to double
							double l_dTemp[3];
							l_dTemp[0] = DOUBLE_little_endian_TO_big_endian((double)l_fTemp[0]);
							l_dTemp[1] = DOUBLE_little_endian_TO_big_endian((double)l_fTemp[1]);
							l_dTemp[2] = DOUBLE_little_endian_TO_big_endian((double)l_fTemp[2]);
	
							// write out that vector
							fwrite(&l_dTemp,8,3,file);
						}
					}
				}
			}
		}
	
		// --------------------------------------------------------
		// now let's write the radius
		// --------------------------------------------------------
		if(AttributeIsDefined(l_refAttributes,L"radius"))
		{
			attr = geo.GetICEAttributeFromName(L"radius");
	
			// also check if the attribute contains any data...
			CICEAttributeDataArray<float> l_vTestData;
			attr.GetDataArrayChunk(0,1,l_vTestData);
			if(l_vTestData.GetCount()>0)
			{
				l_iAttributesWritten++;
	
				// write the length of the name of the attribute's name
				l_iTemp = INT_little_endian_TO_big_endian(int(7));
				fwrite(&l_iTemp,4,1,file);
				// write out the name of the attribute!
				fwrite("radiusPP",1,7,file);
	
				// write the datatype of the particle attribute
				// in this case it is 3 for double array
				l_iTemp = INT_little_endian_TO_big_endian(int(3));
				fwrite(&l_iTemp,4,1,file);
	
				if(attr.IsConstant())
				{
					CICEAttributeDataArray<float> l_vData;
					attr.GetDataArrayChunk(0,1,l_vData);
					double l_dTemp = DOUBLE_little_endian_TO_big_endian((double)(2.0*l_vData[0]));
					for(ULONG i=0;i<l_ulNbParticles;i++)
						fwrite(&l_dTemp,8,1,file);
				}
				else
				{
					// read the data in chunks of 1000 elements
					for(ULONG i=0;i<l_ulNbParticles;i+=g_ulChunksize)
					{
						CICEAttributeDataArray<float> l_vData;
						ULONG l_ulUpperlimit = l_ulNbParticles-i<g_ulChunksize ? l_ulNbParticles-i : g_ulChunksize;
	
						attr.GetDataArrayChunk(i,l_ulUpperlimit,l_vData);
						for(ULONG j=0;j<l_ulUpperlimit;j++)
						{
							// retrieve one float and convert to double
							double l_dTemp = DOUBLE_little_endian_TO_big_endian((double)(2.0*l_vData[j]));
	
							// write out that double
							fwrite(&l_dTemp,8,1,file);
						}
					}
				}
			}
		}
	
		// --------------------------------------------------------
		// now let's write the color!
		// --------------------------------------------------------
		if(AttributeIsDefined(l_refAttributes,L"color"))
		{
			attr = geo.GetICEAttributeFromName(L"color");
	
			// also check if the attribute contains any data...
			CICEAttributeDataArray<CColor4f> l_vTestData;
			attr.GetDataArrayChunk(0,1,l_vTestData);
			if(l_vTestData.GetCount()>0)
			{
				// first part is the rgbPP attribute containing the color:
				l_iAttributesWritten++;
	
				// write the length of the name of the attribute's name
				l_iTemp = INT_little_endian_TO_big_endian(int(5));
				fwrite(&l_iTemp,4,1,file);
				// write out the name of the attribute!
				fwrite("rgbPP",1,5,file);
	
				// write the datatype of the particle attribute
				// in this case it is 5 for vector array
				l_iTemp = INT_little_endian_TO_big_endian(int(5));
				fwrite(&l_iTemp,4,1,file);
	
				if(attr.IsConstant())
				{
					CICEAttributeDataArray<CColor4f> l_vData;
					attr.GetDataArrayChunk(0,1,l_vData);
					double l_dTemp[3];
					l_dTemp[0] = DOUBLE_little_endian_TO_big_endian((double)l_vData[0].GetR());
					l_dTemp[1] = DOUBLE_little_endian_TO_big_endian((double)l_vData[0].GetG());
					l_dTemp[2] = DOUBLE_little_endian_TO_big_endian((double)l_vData[0].GetB());
					for(ULONG i=0;i<l_ulNbParticles;i++)
						fwrite(&l_dTemp,8,3,file);
				}
				else
				{
					// read the data in chunks of 1000 elements
					for(ULONG i=0;i<l_ulNbParticles;i+=g_ulChunksize)
					{
						CICEAttributeDataArray<CColor4f> l_vData;
						ULONG l_ulUpperlimit = l_ulNbParticles-i<g_ulChunksize ? l_ulNbParticles-i : g_ulChunksize;
	
						attr.GetDataArrayChunk(i,l_ulUpperlimit,l_vData);
						for(ULONG j=0;j<l_ulUpperlimit;j++)
						{
							// convert to double
							double l_dTemp[3];
							l_dTemp[0] = DOUBLE_little_endian_TO_big_endian((double)l_vData[j].GetR());
							l_dTemp[1] = DOUBLE_little_endian_TO_big_endian((double)l_vData[j].GetG());
							l_dTemp[2] = DOUBLE_little_endian_TO_big_endian((double)l_vData[j].GetB());
	
							// write out that vector
							fwrite(&l_dTemp,8,3,file);
						}
					}
				}
	
				// second part is the opacity, in moondust this is the alpha of the color
				l_iAttributesWritten++;
	
				// write the length of the name of the attribute's name
				l_iTemp = INT_little_endian_TO_big_endian(int(9));
				fwrite(&l_iTemp,4,1,file);
				// write out the name of the attribute!
				fwrite("opacityPP",1,9,file);
	
				// write the datatype of the particle attribute
				// in this case it is 3 for double array
				l_iTemp = INT_little_endian_TO_big_endian(int(3));
				fwrite(&l_iTemp,4,1,file);
	
				if(attr.IsConstant())
				{
					CICEAttributeDataArray<CColor4f> l_vData;
					attr.GetDataArrayChunk(0,1,l_vData);
					double l_dTemp = DOUBLE_little_endian_TO_big_endian((double)l_vData[0].GetA());
					for(ULONG i=0;i<l_ulNbParticles;i++)
						fwrite(&l_dTemp,8,1,file);
				}
				else
				{
					// read the data in chunks of 1000 elements
					for(ULONG i=0;i<l_ulNbParticles;i+=g_ulChunksize)
					{
						CICEAttributeDataArray<CColor4f> l_vData;
						ULONG l_ulUpperlimit = l_ulNbParticles-i<g_ulChunksize ? l_ulNbParticles-i : g_ulChunksize;
	
						attr.GetDataArrayChunk(i,l_ulUpperlimit,l_vData);
						for(ULONG j=0;j<l_ulUpperlimit;j++)
						{
							// retrieve one float and convert to double
							double l_dTemp = DOUBLE_little_endian_TO_big_endian((double)l_vData[j].GetA());
	
							// write out that double
							fwrite(&l_dTemp,8,1,file);
						}
					}
				}
			}
		}
	
		// update the number of attributes written
		fseek(file,24,SEEK_SET);
		l_iAttributesWritten = INT_little_endian_TO_big_endian(l_iAttributesWritten);
		fwrite(&l_iAttributesWritten,4,1,file);
	
		// close the file stream again
		fclose(file);
	}

	//*/
	return CStatus::OK;
}

