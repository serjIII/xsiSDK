// CSCenterOpPlugin
// Initial code generated by Softimage SDK Wizard
// Executed Tue Sep 26 16:30:59 EDT 2006 by mbelzile
// 
// Example of an operator implemented in C# which connects to a variable number of inputs.
//
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
//
//	Copyright 2008 Autodesk, Inc.  All rights reserved.  
//	Use of this software is subject to the terms of the Autodesk license agreement 
//	provided at the time of installation or download, or which otherwise accompanies 
//	this software in either electronic or hard copy form.   

using System;
using Softimage.XSIOM; // Softimage object model
using Softimage.XSIMath;
using Softimage.XSIUtil;

//
// XSIPlugin class for creating the plug-in items to load. 
// Note: The name of the implementation class must be XSIPlugin
//

public class XSIPlugin : Base
{
	public bool Load(PluginRegistrar in_reg)
	{
		in_reg.Author = "Softimage";
		in_reg.Name = "C# CenterOp Plugin";
		in_reg.Major = 1;
		in_reg.Minor = 0;

		in_reg.RegisterOperator("CSCenterOp");

		in_reg.RegisterMenu(siMenuAnchorPoints.siMenuMainTopLevelID,
							"CSCenterOp_Menu",
							false, /* submenu */
							false /*dynamic*/ );

		return true;
	}
}

//
// CSCenterOp operator implementation
// Note: The name of this class must match the name of the custom operator plug-in item
// 

public class CSCenterOp : Base
{
	CXSIMath m_math;

	// User data used by Update.
	// This is a performance enhancement to
	// avoid creating many temporary math objects
	// during the Update callback

	SIVector3 m_avgVect;
	SITransformation m_transf;

	public CSCenterOp()
	{
		m_math = new CXSIMath();
		m_avgVect = m_math.CreateVector3(0, 0, 0);
		m_transf = m_math.CreateTransform();
	}

	// Note 1: There are no parameters for this operator so we do not
	// implement the Define callback

	// Note 2: User data are stored in this class, so there is no need to implement
	// the Init calback

	// Update
	public bool Update( Context in_ctxt )
	{
		m_avgVect.Set(0, 0, 0);

		OperatorContext ctxt = (OperatorContext)in_ctxt;

		// We use the CustomOperator to find out how many inputs
		// are connected
		CustomOperator op = (CustomOperator)ctxt.Source;
		
		// There is only one port group, containing all the inputs and
		// the single output
		long cntInputs = op.GetNumPortsInGroup(0) - 1;

		// Add all the input objects positions
		for (long i = 0; i < cntInputs; i++)
		{
			KinematicState inputKS = (KinematicState)ctxt.GetInputValue(i /* port */, 0, 0);
			SITransformation tr = (SITransformation)inputKS.GetTransform2(null);
			m_avgVect.AddInPlace( tr.Translation );
		}

		if (cntInputs > 0)
		{
			m_avgVect.ScaleInPlace(1.0 / (double)cntInputs);
		}

		if (op.Debug==1)
		{
			// Note: the Debug parameter can be enabled from the CSCenterOp PPG
			Info("New center position: " + m_avgVect.X.ToString() + ":"
										+ m_avgVect.Y.ToString() + ":" 
										+ m_avgVect.Z.ToString() );
		}

		// Set the new transformation
		m_transf.Translation = m_avgVect;

		// Set the output target with the new translation
		KinematicState output = (KinematicState)ctxt.OutputTarget;
		output.PutTransform2( null, m_transf );	

		return true;
	}
}

//
// CSCenterOp_Menu implementation. We use a menu to create and connect an 
// instance of the CSCenterOp operator. 
// 
// Note: The name of this class must match the name of the menu plug-in item
//

public class CSCenterOp_Menu : Base
{
	public bool Init(Context in_ctxt)
	{
		Menu menu = (Menu)in_ctxt.Source;

		// Create the menu item
		menu.AddCallbackItem("Demo", "DemoCSCenterOp");

		return true;
	}

	// Connect the operator to a null and list of inputs
	CustomOperator ApplyCSCenterOp(XSICollection in_inputs)
	{
		CustomOperator op = null;
		try
		{
			Null centerNull = GetXSI().ActiveSceneRoot.AddNull("Center");

			// Validate the input collection
			// We want to connect to the specific KinematicState
			// but we can accept X3DObjects so that the caller
			// doesn't need to worry about that detail

			XSICollection validInputs = (XSICollection)GetFactory().CreateObject("XSI.Collection");

			for (long i = 0; i < in_inputs.Count; i++)
			{
				SIObject inputCandidate = (SIObject)in_inputs[i];

				if (inputCandidate.IsClassOf(siClassID.siX3DObjectID))
				{
					inputCandidate = ((X3DObject)inputCandidate).Kinematics.Global;
				}

				if (!inputCandidate.IsClassOf(siClassID.siKinematicStateID))
				{
					continue;
				}

				validInputs.Add(inputCandidate);
			}

			op = centerNull.Kinematics.Global.AddCustomOp( "CSCenterOp", validInputs, null /*name*/);
		}
		catch (Exception e)
		{
			Error("Error while connecting CSCenterOp: " + e.ToString());
		}

		return op;
	}

	// Used for demoing the operator
	public bool DemoCSCenterOp(Context in_ctxt)
	{
		try
		{
			Object[] args = new Object[2] { null, false };
			GetXSI().ExecuteCommand("NewScene", args);

			X3DObject sphere1 = GetXSI().ActiveSceneRoot.AddGeometry("Sphere", "MeshSurface", "Sphere1");
			X3DObject sphere2 = GetXSI().ActiveSceneRoot.AddGeometry("Sphere", "NurbsSurface", "Sphere2");
			X3DObject cylinder = GetXSI().ActiveSceneRoot.AddGeometry("Cylinder", "NurbsSurface", "Cylinder");

			sphere1.Kinematics.Global.Parameters["posx"].PutValue2(null, 10);
			sphere1.Kinematics.Global.Parameters["posy"].PutValue2(null, -5);
			sphere2.Kinematics.Global.Parameters["posx"].PutValue2(null, -12);
			sphere2.Kinematics.Global.Parameters["posy"].PutValue2(null, 4);
			cylinder.Kinematics.Global.Parameters["posx"].PutValue2(null, -4);
			cylinder.Kinematics.Global.Parameters["posy"].PutValue2(null, -5);

			XSICollection inputs = (XSICollection)GetFactory().CreateObject("XSI.Collection");
			inputs.Add(sphere1);
			inputs.Add(sphere2);
			inputs.Add(cylinder);

			CustomOperator op = this.ApplyCSCenterOp(inputs);

			// Retrieve the Null kine state that is driven by the operator
			KinematicState ks = (KinematicState)op.OutputPorts[0].Target2;

			// Pull the output of the operator
			SITransformation tr = (SITransformation)ks.GetTransform2(null);
			SIVector3 pos = tr.Translation;

			Log("Position between spheres: " + pos.X.ToString() + ":"
											+ pos.Y.ToString() + ":"
											+ pos.Z.ToString());
		}
		catch (Exception e)
		{
			Error("Error while demoing CSCenterOp: " + e.ToString());
		}
		return true;
	}
}

// 
// Base class with common services. Used by plug-in item classes such as 
// the CSCenterOp operator class.
// 

public class Base
{
	CXSIApplicationClass m_xsi;
	CXSIFactoryClass m_fact;

	protected Base()
	{
		m_xsi = new CXSIApplicationClass();
		m_fact = new CXSIFactoryClass();
	}
	protected bool Log(String str)
	{
		m_xsi.LogMessage(str, siSeverity.siVerbose);
		return true;
	}

	protected bool Info(String str)
	{
		m_xsi.LogMessage(str, siSeverity.siInfo);
		return true;
	}

	protected bool Error(String str)
	{
		m_xsi.LogMessage(str, siSeverity.siError);
		return true;
	}

	protected XSIApplication GetXSI()
	{
		return m_xsi;
	}

	protected XSIFactory GetFactory()
	{
		return m_fact;
	}
}
