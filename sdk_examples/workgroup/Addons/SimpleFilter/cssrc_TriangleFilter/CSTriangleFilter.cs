// CSTriangleFilter Plug-in
// Initial code generated by Softimage SDK Wizard
// Executed Fri Sep 29 11:25:01 EDT 2006 by mbelzile
// 
// This samples shows how to implement a triangle filter in C#. 
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
//
//	Copyright 2008 Autodesk, Inc.  All rights reserved.  
//	Use of this software is subject to the terms of the Autodesk license agreement 
//	provided at the time of installation or download, or which otherwise accompanies 
//	this software in either electronic or hard copy form.   

using System;
using Softimage.XSIOM; // Softimage object model

//
// XSIPlugin class for creating the plug-in items to load. 
// Note: The name of the implementation class must be XSIPlugin
//

public class XSIPlugin : Base
{
	public bool Load( PluginRegistrar in_reg )
	{
		in_reg.Author = "Softimage";
		in_reg.Name = "C# Triangle Filter Plug-in";
		in_reg.Major = 1;
		in_reg.Minor = 0;

		in_reg.RegisterFilter("CSTriangleFilter", siFilterType.siFilterSubComponentPolygon);

		return true;
	}
}

//
// CSTriangleFilter class implementation
// Note: The name of this class must match the name of the filter plug-in item
// 
public class CSTriangleFilter : Base
{
    public bool Match(Context in_ctxt)
    {
        return GenericPolygonNbPts_Match(in_ctxt, 3);
    }

    public bool Subset(Context in_ctxt)
    {
        return GenericPolygonNbPts_Subset(in_ctxt, 3);
    }

    static Array Redim(Array origArray, Int32 desiredSize)
    {
        // Determine the types of each element
        Type t = origArray.GetType().GetElementType();

        // Construct a new array with the desired number of elements
        // Each element is the same type as was in the original array
        Array newArray = Array.CreateInstance(t, desiredSize);

        // Copy the element from the original array in to the new array
        Array.Copy(origArray, 0, newArray, 0, Math.Min(origArray.Length, desiredSize));

        // Return the new array
        return newArray;
    }

    static bool IsAPolygonSubComponent( SIObject in_obj )
    {
	    bool bIsAPolygonSubComponent = false;
	    if ( in_obj.IsClassOf( siClassID.siSubComponentID) &&
		    in_obj.Type == "polySubComponent" )
        {
            bIsAPolygonSubComponent = true;
        }
        return bIsAPolygonSubComponent;
	}

    bool GenericPolygonNbPts_Match( Context in_context, int in_targetNbPts )
    {
	    SIObject in_object = (SIObject)in_context.GetAttribute( "Input" );

	    if (!IsAPolygonSubComponent( in_object ) )
        {
            return false;
        }

	    // get the polygon object(s) from the subcomponent
        SubComponent subComp = (SubComponent)in_object;

        PolygonFaceCollection polygons = (PolygonFaceCollection)subComp.ComponentCollection;

	    // lets find a counter example 

	    Array aNodeIndexArray = (Array)polygons.PolygonNodePolygonFaceIndexArray;

        FacetCollection polyFacets = (FacetCollection)polygons;
        Array aPolyIndexArray = (Array)polyFacets.IndexArray;

	    if (in_targetNbPts > 4 )
        {
            int j = 0;
		    for( int poly=0; poly<aPolyIndexArray.Length; poly++)
            {
			    int count = (int)aNodeIndexArray.GetValue(j);
			    if (count <= 4 )
                {
				    //mismatch found
				    return false;
                }
			    j = j + count + 1;
		    }
        }
	    else
        {
		    int j = 0;
            for( int poly=0; poly<aPolyIndexArray.Length; poly++)
		    {
                int count = (int)aNodeIndexArray.GetValue(j);
			    if ( count != in_targetNbPts )
                {
				    //mismatch found
				    return false;
			    }
			    j = j + count + 1;
		    }
	    }

	    return true;
    }

    bool GenericPolygonNbPts_Subset( Context in_context, int in_targetNbPts )
    {
        XSICollection coll = (XSICollection)GetFactory().CreateObject("XSI.Collection");

        XSICollection in_objects = (XSICollection)in_context.GetAttribute( "Input" );

        foreach( CollectionItem obj in in_objects )
        {
		    // get the polygon object(s) from each subcomponent and add the triangles
		    // to the output collection
		    SubComponent subc = (SubComponent)obj.SubComponent;

		    if ( IsAPolygonSubComponent( subc ) )
            {
                PolygonFaceCollection polygons = (PolygonFaceCollection)subc.ComponentCollection;

			    int nb_indices = 0;

                Array aNodeIndexArray = (Array)polygons.PolygonNodePolygonFaceIndexArray;

                FacetCollection polyFacets = (FacetCollection)polygons;
                Array aPolyIndexArray = (Array)polyFacets.IndexArray;
                
			    if ( in_targetNbPts > 4 )
                {
				    int j = 0;
				    for( int poly = 0; poly<aPolyIndexArray.Length; poly++)
                    {
                        int count = (int)aNodeIndexArray.GetValue(j);
					    if (count > 4)
                        {
						    aPolyIndexArray.SetValue(aPolyIndexArray.GetValue(poly), nb_indices);
						    nb_indices++;
					    }
					    j = j + count + 1;
				    }
                }
			    else
                {
				    int j = 0;
				    for( int poly = 0; poly<aPolyIndexArray.Length; poly++)
                    {
                        int count = (int)aNodeIndexArray.GetValue(j);
					    if (count == in_targetNbPts )
                        {
                            aPolyIndexArray.SetValue(aPolyIndexArray.GetValue(poly), nb_indices);
						    nb_indices++;
					    }
					    j = j + count + 1;
				    }
			    }

			    if (nb_indices > 0 )
                {
                    aPolyIndexArray = Redim( aPolyIndexArray, nb_indices );

                    SubComponent oSubComponent = subc.Parent3DObject.ActivePrimitive.GetGeometry(0, siConstructionMode.siConstructionModeSecondaryShape).CreateSubComponent(StringModule.siPolygonCluster, aPolyIndexArray);

				    // add the subcomponent to the output collection
				    coll.Add( oSubComponent );
			    }
		    }
	    }

	    // returns the filter objects 
	    in_context.SetAttribute( "Output", coll);

	    return coll.Count > 0;
    }
}

// 
// This sample class is used to demonstrate how a base class can be used to implement plug-in items.
// 

public class Base
{
	CXSIApplicationClass m_xsi;
	CXSIFactoryClass m_fact;

	protected Base()
	{
		m_xsi = new CXSIApplicationClass();
		m_fact = new CXSIFactoryClass();
	}
	protected bool Log(String str)
	{
		m_xsi.LogMessage(str, siSeverity.siVerbose);
		return true;
	}

	protected bool Info(String str)
	{
		m_xsi.LogMessage(str, siSeverity.siInfo);
		return true;
	}

	protected bool Error(String str)
	{
		m_xsi.LogMessage(str, siSeverity.siError);
		return true;
	}

	protected XSIApplication GetXSI()
	{
		return m_xsi;
	}

	protected XSIFactory GetFactory()
	{
		return m_fact;
	}
}
