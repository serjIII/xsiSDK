/******************************************************************************
* Module:  show_edges.cpp
* Version: 1
* Author:   This file was generated by the Softimage shader wizard v1.0
*
* This file contains the definition for show_edges.
* Description: Show Edges Example Shader - highlights the edges of the triangulated object.
*
*	Copyright 2008 Autodesk, Inc.  All rights reserved.  
*	Use of this software is subject to the terms of the Autodesk license agreement 
*	provided at the time of installation or download, or which otherwise accompanies 
*	this software in either electronic or hard copy form.   
******************************************************************************/

#include <math.h>

#include "show_edges.h"

/*------------------------------------------------------------------*/
/* Two Helper functions for the show_edges shader                   */
static miBoolean GetVertices(miState *state, miVector *P);
static miBoolean OnEdge(miVector *Q, miVector *P, miScalar in_thickness);

/*------------------------------------------------------------------*/
/* Version number function for the show_edges shader                */
DLLEXPORT int show_edges_version(void) { return 1; }

/*------------------------------------------------------------------*/
/* Main entry point for the show edges shader.                      */
DLLEXPORT miBoolean show_edges(	miColor 			*out_pResult,
	   							miState 			*state,
								show_edges_params	*in_pParams)
{
	/* Get the thickness of the lines to draw */
	miScalar l_thickness = *mi_eval_scalar( &(in_pParams->m_thickness) );
	miVector P[3];

	/* Get the points of the triangle the ray intersected */
	if (!GetVertices(state, P)) return miFALSE;

	if (OnEdge(&(state->point), P, l_thickness))
	{
		/* Point is on the edge of the triangle */
		/* Evaluate the edge color and store it in the result*/
		*out_pResult = *mi_eval_color( &(in_pParams->m_edgecolor) );
	}
	else
	{
		/* Point is on the interior of the triangle */
		/* Evaluate the interior color and store it in the result*/
		*out_pResult = *mi_eval_color( &(in_pParams->m_incolor) );
	}
	return miTRUE;
}

/*-----------------------------------------------------------------*/
/* Function to get the vertices of the triangle in internal space */
static miBoolean GetVertices(miState *state, miVector *P)
{
	const miVector *verts[3];
	int i;

	if (!mi_tri_vectors(state, 'p', 0, &verts[0], &verts[1], &verts[2] ))
	{
		/* Problem... */
		return miFALSE;
	}
	switch (state->options->render_space)
	{
		case 'o':
		{	/* points are in object space. */
			for (i=0; i<3; i++) mi_point_from_object(state, &P[i], verts[i]);
		} break;
		case 'c':
		{	/* points are in camera space. */
			for (i=0; i<3; i++) mi_point_from_camera(state, &P[i], verts[i]);
		} break;
		default:
		{
			/* mixed space?  Not handled. */
			return miFALSE;
		} break;
	}

	/* Success */
	return miTRUE;
}

/*-------------------------------------------------------------------*/
/* Function to determine if the intersection point Q is in_thickness */
/* units away from the edges of the triangle P */
static miBoolean OnEdge(miVector *Q, miVector *P, miScalar in_thickness)
{
	int i;
	miScalar l_thicksq = in_thickness*in_thickness;

	/* Check against all three edges */
	for (i=0; i<3; i++)
	{
		miVector l_vPiQ, l_vEdge;
		miScalar l_sDotprod, l_sDistSq, l_vEdgeLen;

		/* Project the vector P[i]Q onto the edge P[i]P[(i+1)%3]. */
		mi_vector_sub(&l_vPiQ, Q, &P[i]);
		mi_vector_sub(&l_vEdge, &P[(i+1)%3], &P[i]);

		l_vEdgeLen = mi_vector_norm(&l_vEdge);
		if (l_vEdgeLen < miGEO_SCALAR_EPSILON)
		{
			/* Degenerate triangle - trivially near the edge. */
			return miTRUE;
		}

		l_sDotprod = mi_vector_dot(&l_vPiQ,&l_vEdge)/l_vEdgeLen;

		/* We now know two sides of the right angle triangle: */
		/* the base (l_sDotProd) and the hypotenuse (the length of l_vPiQ).*/
		/* Compute the last side, which is the distance of Q from the edge,*/
		/* using Pythagorus: a^2 + b^2 = h^2. */
		/* We use mi_vector_dot to compute the length of l_vPiQ, since we */ 
		/* want the square of the length anyways */
		l_sDistSq = mi_vector_dot(&l_vPiQ, &l_vPiQ) - l_sDotprod*l_sDotprod;

		/* We don't bother finding the true distance, since this involves a*/
		/* square root. Instead, we compare against the square of the */
		/* desired thickness */
		if (l_sDistSq <= l_thicksq)
		{
			/* This point is close enough to the edge */
			return miTRUE;
		}
	}

	/* We aren't close to any of the edges - we're on the inside */
	return miFALSE;
}
