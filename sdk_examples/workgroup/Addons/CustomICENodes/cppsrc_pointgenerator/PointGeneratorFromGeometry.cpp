// PointGeneratorFromGeometry Plugin
// Initial code generated by Softimage SDK Wizard
// Executed Mon Feb 2 15:16:26 EST 2009 by belzilm
// 
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>

#include <xsi_icenodecontext.h>
#include <xsi_icenodedef.h>
#include <xsi_command.h>
#include <xsi_factory.h>
#include <xsi_math.h>
#include <xsi_vector2f.h>
#include <xsi_vector3f.h>
#include <xsi_vector4f.h>
#include <xsi_matrix3f.h>
#include <xsi_matrix4f.h>
#include <xsi_rotationf.h>
#include <xsi_quaternionf.h>
#include <xsi_color4f.h>
#include <xsi_shape.h>
#include <xsi_indexset.h>
#include <xsi_dataarray.h>
#include <xsi_dataarray2D.h>
#include <xsi_icegeometry.h>
#include <xsi_doublearray.h>
#include <xsi_random.h>
#include <xsi_progressbar.h>
#include <xsi_uitoolkit.h>
#include <vector>

// Defines port, group and map identifiers used for registering the ICENode
enum IDs
{
	ID_IN_geometry = 0,
	ID_IN_sampling_type = 1,
	ID_IN_random_point_count = 2,
	ID_G_100 = 100,
	ID_G_101 = 101,
	ID_OUT_sample_points = 200,
	ID_TYPE_CNS = 400,
	ID_STRUCT_CNS,
	ID_CTXT_CNS,
	ID_UNDEF = ULONG_MAX
};

XSI::CStatus RegisterPointGeneratorFromGeometry( XSI::PluginRegistrar& in_reg );

using namespace XSI; 

XSIPLUGINCALLBACK CStatus XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"belzilm");
	in_reg.PutName(L"PointGeneratorFromGeometry Plugin");
	in_reg.PutVersion(1,0);

	RegisterPointGeneratorFromGeometry( in_reg );

	return CStatus::OK;
}

CStatus RegisterPointGeneratorFromGeometry( PluginRegistrar& in_reg )
{
	ICENodeDef nodeDef;
	nodeDef = Application().GetFactory().CreateICENodeDef(L"PointGeneratorFromGeometry",L"Point Generator From Geometry");

	CStatus st;

	// Add input ports and groups.
	st = nodeDef.AddPortGroup(ID_G_100);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddPortGroup(ID_G_101);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(	ID_IN_geometry, ID_G_100,
								siICENodeDataGeometry,siICENodeStructureSingle,siICENodeContextSingleton,
								L"geometry",L"geometry" );
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(	ID_IN_sampling_type, ID_G_101,
								siICENodeDataLong,siICENodeStructureSingle,siICENodeContextSingleton,
								L"sampling type",L"sampling type",(LONG)0);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(	ID_IN_random_point_count,ID_G_101,
								siICENodeDataLong,siICENodeStructureSingle,siICENodeContextSingleton,
								L"random points",L"random points",(LONG)3);
	st.AssertSucceeded( ) ;

	// Add output ports.
	st = nodeDef.AddOutputPort(	ID_OUT_sample_points,
								siICENodeDataVector3,siICENodeStructureSingle,siICENodeContextElementGenerator,
								L"sample points",L"sample points");
	st.AssertSucceeded( ) ;

	PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
	nodeItem.PutCategories(L"Custom ICENode Sample");

	return CStatus::OK;
}

/*
	PointGeneratorFromGeometry_BeginEvaluate:
		This callback generates points according to the sampling method selected by the user.
	
*/
XSIPLUGINCALLBACK CStatus PointGeneratorFromGeometry_BeginEvaluate( ICENodeContext& in_ctxt )
{
	CDataArrayLong samplingType( in_ctxt, ID_IN_sampling_type );
	CDataArrayLong randomPointCount( in_ctxt, ID_IN_random_point_count );

	CICEGeometry geom( in_ctxt, ID_IN_geometry );
	
	CDoubleArray points;
	geom.GetPointPositions( points ) ;

	XSI::MATH::CMatrix4f transfo;
	geom.GetTransformation( transfo );
			
	std::vector< MATH::CVector3f >* pPointVector = new std::vector< MATH::CVector3f >;
	
	switch ( samplingType[0] )
	{
		/* polygon center points */
		case 0:
		{
			ULONG nCount = geom.GetPolygonCount();			
			in_ctxt.PutNumberOfElementsToProcess( nCount );
			
			CLongArray sizes;
			CLongArray indices;
			geom.GetPolygonIndices( sizes, indices );
			
			ULONG nOffset = 0;
			
			for (ULONG i=0; i<nCount; i++)
			{
				MATH::CVector3f vTotal;
				for (ULONG j=0; j<(ULONG)sizes[i]; j++, nOffset++)	
				{
					MATH::CVector3f v(	(float)points[ indices[nOffset]*3 ], 
										(float)points[ indices[nOffset]*3+1 ], 
										(float)points[ indices[nOffset]*3+2 ] );
					vTotal += v;					
				}
				
				vTotal *= 1.0f/sizes[i];
				vTotal.MulByMatrix4InPlace( transfo );				
				pPointVector->push_back( vTotal );
			}
		}
		break;
		
		/* triangle center points */		
		case 1:
		{
			ULONG nCount = geom.GetTriangleCount();			
			in_ctxt.PutNumberOfElementsToProcess( nCount );
			
			CLongArray indices;
			geom.GetTrianglePointIndices( indices );
			
			ULONG nOffset = 0;
			
			for (ULONG i=0; i<nCount; i++)
			{
				MATH::CVector3f vTotal;
				for (ULONG j=0; j<3; j++, nOffset++)	
				{
					MATH::CVector3f v(	(float)points[ indices[nOffset]*3 ], 
										(float)points[ indices[nOffset]*3+1 ], 
										(float)points[ indices[nOffset]*3+2 ] );
					vTotal += v;					
				}
				
				vTotal *= 1.0f/3;
				vTotal.MulByMatrix4InPlace( transfo );				
				pPointVector->push_back( vTotal );
			}
		}
		break;
		
		/* segment center points */		
		case 2:
		{
			ULONG nCount = geom.GetSegmentCount();			
			in_ctxt.PutNumberOfElementsToProcess( nCount );
			
			CLongArray indices;
			geom.GetSegmentIndices( indices );
			
			ULONG nOffset = 0;
			
			for (ULONG i=0; i<nCount; i++)
			{
				MATH::CVector3f vTotal;
				for (ULONG j=0; j<2; j++, nOffset++)	
				{
					MATH::CVector3f v(	(float)points[ indices[nOffset]*3 ], 
										(float)points[ indices[nOffset]*3+1 ], 
										(float)points[ indices[nOffset]*3+2 ] );
					vTotal += v;					
				}
				
				vTotal *= 1.0f/2;
				vTotal.MulByMatrix4InPlace( transfo );				
				pPointVector->push_back( vTotal );
			}
		}
		break;

		/* Geometry points */		
		case 3:
		{		
			ULONG nCount = geom.GetPointPositionCount();			
			in_ctxt.PutNumberOfElementsToProcess( nCount );
						
			ULONG nOffset = 0;
			
			for (ULONG i=0; i<nCount; i++)
			{
				MATH::CVector3f v( (float)points[ i*3 ], (float)points[ i*3+1 ], (float)points[ i*3+2 ] );
				v.MulByMatrix4InPlace( transfo );				
				pPointVector->push_back( v );
			}			
		}
		break;

		/*	Randomly sparsed triangle center points (lousely based on barycentric coordinates)
		*/		
		case 4:
		{
#ifdef SHOW_PROGRESS_BAR		
			if ( geom.IsDirty( XSI::CICEGeometry::siPointPositionDirtyState ) )
			{
				// Simple example to show how to use a progress bar with custom nodes to give user-feedback.
				// Note: ProgressBar should always be used from a single-thread callback such as 
				// PointGeneratorFromGeometry_BeginEvaluate. 
				UIToolkit kit = Application().GetUIToolkit();
				ProgressBar bar = kit.GetProgressBar();

				bar.PutMaximum( 50000 );
				bar.PutStep( 10 );
				bar.PutCaption( L"Ramdom points sample progress bar" );
				bar.PutVisible( true );
				while (!bar.IsCancelPressed() && bar.GetValue() < bar.GetMaximum() )
				{
					CValue newVal(bar.Increment());
					bar.PutStatusText( L"Frame " + newVal.GetAsText() );
				}
				
				// Clear all dirty states.
				geom.ClearState( );
			}		
#endif		
			ULONG nRandomPointCount = randomPointCount[0];
			ULONG nCount = geom.GetTriangleCount();			
			in_ctxt.PutNumberOfElementsToProcess( nCount * nRandomPointCount );
			
			CLongArray indices;
			geom.GetTrianglePointIndices( indices );
			
			ULONG nOffset = 0;
			
			MATH::CRandom rand( 10 );
			for (ULONG i=0; i<nCount; i++)
			{
				for (ULONG j=0; j<nRandomPointCount; j++)	
				{
					float P = rand.GetNormalizedValue();
					rand++;

					float Q = rand.GetNormalizedValue();
					rand++;

					if (P+Q > 1.0f)
					{
						float temp = P;
						P = 1.0f - Q;
						Q = 1.0f - temp;
					}

					MATH::CVector3f p1(	(float)points[ indices[nOffset]*3 ], 
										(float)points[ indices[nOffset]*3+1 ], 
										(float)points[ indices[nOffset]*3+2 ] );
					MATH::CVector3f p2( (float)points[ indices[nOffset+1]*3 ], 
										(float)points[ indices[nOffset+1]*3+1 ], 
										(float)points[ indices[nOffset+1]*3+2 ] );
					MATH::CVector3f p3( (float)points[ indices[nOffset+2]*3 ], 
										(float)points[ indices[nOffset+2]*3+1 ], 
										(float)points[ indices[nOffset+2]*3+2 ] );
					
					MATH::CVector3f v1(p2);
					v1 -= p1;
					v1 *= P;

					MATH::CVector3f v2(p3);
					v2 -= p1;
					v2 *= Q;
					
					MATH::CVector3f vTotal(p1);
					vTotal += v1;
					vTotal += v2;

					vTotal.MulByMatrix4InPlace( transfo );				
					pPointVector->push_back( vTotal );
				}				
				nOffset += 3;
			}
		}
		break;

		default:
		{
			in_ctxt.PutNumberOfElementsToProcess( 0 );
		}
	};
	
	in_ctxt.PutUserData( (CValue::siPtrType) pPointVector );
	
	return CStatus::OK;
}

/*
	PointGeneratorFromGeometry_Evaluate:	
		Sets the node output port with the points computed in the _BeginEvaluate callback.

*/
XSIPLUGINCALLBACK CStatus PointGeneratorFromGeometry_Evaluate( ICENodeContext& in_ctxt )
{
	ULONG out_portID = in_ctxt.GetEvaluatedOutputPortID( );

	switch( out_portID )
	{
		case ID_OUT_sample_points:
		{
			std::vector<MATH::CVector3f>* pPointVector = (std::vector<MATH::CVector3f>*)(CValue::siPtrType)in_ctxt.GetUserData( );
		
			CDataArrayVector3f outData( in_ctxt );

			CIndexSet indexSet( in_ctxt );
			for(CIndexSet::Iterator it = indexSet.Begin(); it.HasNext(); it.Next())
			{
				// Note: The output buffer is relative to the 'batch' data therefore we can index the batch with the iterator directly.
				// On the other hand pPointVector has to be indexed with the 'batch' global index i.e. CIndexSet::Iterator::GetAbsoluteIndex()
				outData[it] = (*pPointVector)[ it.GetAbsoluteIndex() ]; 
			}
		}
		break;
	};

	return CStatus::OK;
}

/*
	PointGeneratorFromGeometry_EndEvaluate:
		Release the memeory allocated to store the points;
	
*/
XSIPLUGINCALLBACK CStatus PointGeneratorFromGeometry_EndEvaluate( ICENodeContext& in_ctxt )
{
	CValue userData = in_ctxt.GetUserData( );
	if (userData.IsEmpty())
	{
		return CStatus::OK;
	}
	
	std::vector<MATH::CVector3f>* pPointVector = (std::vector<MATH::CVector3f>*)(CValue::siPtrType)userData;
	
	if (pPointVector)
		delete pPointVector;
	
	in_ctxt.PutUserData( CValue() );
	
	return CStatus::OK;
}
