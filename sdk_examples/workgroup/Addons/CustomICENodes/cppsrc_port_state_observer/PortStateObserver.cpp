// Port State Observer Plugin
// Initial code generated by Softimage SDK Wizard
// Executed Thu Feb 26 10:12:13 EST 2009 by belzilm
// 
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>

#include <xsi_icenodecontext.h>
#include <xsi_icenodedef.h>
#include <xsi_command.h>
#include <xsi_factory.h>
#include <xsi_longarray.h>
#include <xsi_doublearray.h>
#include <xsi_math.h>
#include <xsi_vector2f.h>
#include <xsi_vector3f.h>
#include <xsi_vector4f.h>
#include <xsi_matrix3f.h>
#include <xsi_matrix4f.h>
#include <xsi_rotationf.h>
#include <xsi_quaternionf.h>
#include <xsi_color4f.h>
#include <xsi_shape.h>
#include <xsi_icegeometry.h>
#include <xsi_iceportstate.h>
#include <xsi_indexset.h>
#include <xsi_dataarray.h>
#include <xsi_dataarray2D.h>

// Defines port, group and map identifiers used for registering the ICENode
enum IDs
{
	ID_IN_Data = 0,
	ID_IN_GeometryGroup = 1,
	ID_IN_NurbsCurve = 2,
	ID_IN_MeshSurf = 3,
	ID_IN_NurbsSurf = 4,
	ID_IN_PointCloud = 5,
	ID_IN_LogChanges = 6,
	ID_G_100 = 100,
	ID_G_101 = 101,
	ID_G_102 = 102,
	ID_G_103 = 103,
	ID_G_104 = 104,
	ID_G_105 = 105,
	ID_G_106 = 106,
	ID_OUT_OutPort = 200,
	ID_TYPE_CNS = 400,
	ID_STRUCT_CNS,
	ID_CTXT_CNS,
	ID_UNDEF = ULONG_MAX
};

XSI::CStatus RegisterPort_State_Observer( XSI::PluginRegistrar& in_reg );

using namespace XSI; 

XSIPLUGINCALLBACK CStatus XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"belzilm");
	in_reg.PutName(L"Port State Observer Plugin");
	in_reg.PutVersion(1,0);

	RegisterPort_State_Observer( in_reg );

	//RegistrationInsertionPoint - do not remove this line

	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
	CString strPluginName;
	strPluginName = in_reg.GetName();
	Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
	return CStatus::OK;
}

CStatus RegisterPort_State_Observer( PluginRegistrar& in_reg )
{
	ICENodeDef nodeDef;
	nodeDef = Application().GetFactory().CreateICENodeDef(L"Port_State_Observer",L"Port State Observer");

	CStatus st;

	// Add input ports and groups.
	st = nodeDef.AddPortGroup(ID_G_100);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddPortGroup(ID_G_101);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddPortGroup(ID_G_102);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddPortGroup(ID_G_103);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddPortGroup(ID_G_104);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddPortGroup(ID_G_105);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddPortGroup(ID_G_106);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_Data,ID_G_100,siICENodeInputDataAny,siICENodeStructureSingle,siICENodeContextSingleton,L"Data",L"Data",CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_GeometryGroup,ID_G_101,siICENodeDataGeometry,siICENodeStructureSingle,siICENodeContextSingleton,L"GeometryGroup",L"GeometryGroup",CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_NurbsCurve,ID_G_102,siICENodeDataGeometry,siICENodeStructureSingle,siICENodeContextSingleton,L"NurbsCurve",L"NurbsCurve",CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_MeshSurf,ID_G_103,siICENodeDataGeometry,siICENodeStructureSingle,siICENodeContextSingleton,L"MeshSurf",L"MeshSurf",CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_NurbsSurf,ID_G_104,siICENodeDataGeometry,siICENodeStructureSingle,siICENodeContextSingleton,L"NurbsSurf",L"NurbsSurf",CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_PointCloud,ID_G_105,siICENodeDataGeometry,siICENodeStructureSingle,siICENodeContextSingleton,L"PointCloud",L"PointCloud",CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_LogChanges,ID_G_106,siICENodeDataBool,siICENodeStructureSingle,siICENodeContextSingleton,L"LogChanges",L"LogChanges",0,ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	// Add output ports.
	st = nodeDef.AddOutputPort(ID_OUT_OutPort,siICENodeDataFloat,siICENodeStructureSingle,siICENodeContextSingleton,L"OutPort",L"OutPort",ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
	nodeItem.PutCategories(L"Custom ICENode Sample");

	return CStatus::OK;
}

static void _LogGeometryStates( CICEGeometry& in_geom, const CString& in_portName, double in_dCurrentFrame, bool in_bClearState )
{
	if ( in_geom.IsDirty( CICEGeometry::siAnyDirtyState ) )
	{
		bool bTypeDirtyState = in_geom.IsDirty( CICEGeometry::siGeometryTypeDirtyState );
		bool bTransfoDirtyState = in_geom.IsDirty( CICEGeometry::siTransformationDirtyState );
		bool bPointsDirtyState = in_geom.IsDirty( CICEGeometry::siPointPositionDirtyState );
		bool bTopologyDirtyState = in_geom.IsDirty( CICEGeometry::siTopologyDirtyState );
	
		if ( in_bClearState )
		{
			in_geom.ClearState();
		}
	
		Application app;
			
		// Don't log redundant information:
		//		bTypeDirtyState always implies bTransfoDirtyState + bPointsDirtyState + bTopologyDirtyState
		//		bTopologyDirtyState always implies bPointsDirtyState

		if ( bTypeDirtyState)
		{
			app.LogMessage( ">>> Port " + in_portName + " siGeometryTypeDirtyState at frame " + CString(in_dCurrentFrame) + " is dirty" );
		}
		else
		{
			if ( bTransfoDirtyState) 
			{
				app.LogMessage( ">>> Port " + in_portName + " siTransformationDirtyState at frame " + CString(in_dCurrentFrame) + " is dirty" );
			}

			if ( bTopologyDirtyState)
			{
				app.LogMessage( ">>> Port " + in_portName + " siTopologyDirtyState at frame " + CString(in_dCurrentFrame) + " is dirty" );
			}
			else if ( bPointsDirtyState)
			{
				app.LogMessage( ">>> Port " + in_portName + " siPointPositionDirtyState at frame " + CString(in_dCurrentFrame) + " is dirty" );
			}
		}
	}
}

static void LogGeometryStates( CICEGeometry& in_geom, const CString& in_portName, double in_dCurrentFrame )
{
	CICEGeometry::Type geomtype = in_geom.GetGeometryType();
	switch( geomtype )
	{
		case CICEGeometry::siGroupType:
		{
			// Note: ClearState on sub-geometries will clear the states for the entire group geometry. It's
			// recommended to call ClearState only on the group geometry to avoid inconsistencies.
			_LogGeometryStates( in_geom, in_portName, in_dCurrentFrame, false );
			
			for (ULONG i=0; i<in_geom.GetSubGeometryCount(); i++)
			{
				CICEGeometry l_subGeom( in_geom.GetSubGeometry(i) );
				_LogGeometryStates( l_subGeom, in_portName + CString(i), in_dCurrentFrame, false );
			}
			in_geom.ClearState();
		}
		break;
		
		default:
		{
			_LogGeometryStates( in_geom, in_portName, in_dCurrentFrame, true );
		}
	}
}

static void LogPortStates( CICEPortState& in_port, const CString& in_portName, double in_dCurrentFrame )
{							
	if ( in_port.IsDirty( CICEPortState::siAnyDirtyState ) )
	{
		bool bTypeDirtyState = in_port.IsDirty( CICEPortState::siTypeDirtyState );
		bool bDataDirtyState = in_port.IsDirty( CICEPortState::siDataDirtyState );
		bool bTimeDirtyState = in_port.IsDirty( CICEPortState::siTimeDirtyState );
	
		in_port.ClearState();
	
		Application app;
		
		// Don't log redundant information:
		// bTypeDirtyState always implies bDataDirtyState + bTimeDirtyState
		// bDataDirtyState always implies bTimeDirtyState

		if ( bTypeDirtyState)
		{
			app.LogMessage( ">>> Port " + in_portName + " siTypeDirtyState at frame " + CString(in_dCurrentFrame) + " is dirty" );
		}
		else
		{
			if ( bDataDirtyState)
			{
				app.LogMessage( ">>> Port " + in_portName + " siDataDirtyState at frame " + CString(in_dCurrentFrame) + " is dirty" );
			}			
			else if ( bTimeDirtyState)
			{
				app.LogMessage( ">>> Port " + in_portName + " siTimeDirtyState at frame " + CString(in_dCurrentFrame) + " is dirty" );
			}
		}
	}
}

XSIPLUGINCALLBACK CStatus Port_State_Observer_BeginEvaluate( ICENodeContext& in_ctxt )
{
	CDataArrayBool logChanges( in_ctxt, ID_IN_LogChanges );
	
	if ( !logChanges[0] )
	{
		return CStatus::OK;
	}

	CICEGeometry geomGroup( in_ctxt, ID_IN_GeometryGroup );
	CICEGeometry geomCurve( in_ctxt, ID_IN_NurbsCurve );
	CICEGeometry geomMesh( in_ctxt, ID_IN_MeshSurf );
	CICEGeometry geomNurbsSurf( in_ctxt, ID_IN_NurbsSurf );
	CICEGeometry geomCloud( in_ctxt, ID_IN_PointCloud );
	CICEPortState portGeomGroup( in_ctxt, ID_IN_GeometryGroup );
	CICEPortState portGeomCurve( in_ctxt, ID_IN_NurbsCurve );
	CICEPortState portGeomMesh( in_ctxt, ID_IN_MeshSurf );
	CICEPortState portGeomNurbsSurf( in_ctxt, ID_IN_NurbsSurf );
	CICEPortState portGeomCloud( in_ctxt, ID_IN_PointCloud );
	
	Application app;
	app.LogMessage( "--- State changes since last log ---" );

	double dCurrentFrame = in_ctxt.GetTime();
	LogGeometryStates( geomGroup, L"GeometryGroup", dCurrentFrame );
	LogPortStates( portGeomGroup, L"GeometryGroup", dCurrentFrame );
	LogGeometryStates( geomCurve, L"NurbsCurve", dCurrentFrame );
	LogPortStates( portGeomCurve, L"NurbsCurve", dCurrentFrame );
	LogGeometryStates( geomMesh, L"MeshSurf", dCurrentFrame );
	LogPortStates( portGeomMesh, L"MeshSurf", dCurrentFrame );
	LogGeometryStates( geomNurbsSurf, L"NurbsSurf", dCurrentFrame );
	LogPortStates( portGeomNurbsSurf, L"NurbsSurf", dCurrentFrame );
	LogGeometryStates( geomCloud, L"PointCloud", dCurrentFrame );
	LogPortStates( portGeomCloud, L"PointCloud", dCurrentFrame );

	CICEPortState data( in_ctxt, ID_IN_Data );	
	LogPortStates( data, L"Data", dCurrentFrame );
	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus Port_State_Observer_Evaluate( ICENodeContext& in_ctxt )
{
	ULONG out_portID = in_ctxt.GetEvaluatedOutputPortID( );

	switch( out_portID )
	{
		case ID_OUT_OutPort:
		{
			CDataArrayFloat outData( in_ctxt );							
			outData[ 0 ] = 5.0;				
		}
		break;
	};

	return CStatus::OK;
}

