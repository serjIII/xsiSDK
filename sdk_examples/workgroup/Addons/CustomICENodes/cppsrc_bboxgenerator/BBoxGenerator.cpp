// BBoxGenerator Plugin
// Initial code generated by Softimage SDK Wizard
// Executed Sun Dec 16 18:36:55 EST 2007 by mbelzile
// 
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
//
//	Copyright 2008 Autodesk, Inc.  All rights reserved.  
//	Use of this software is subject to the terms of the Autodesk license agreement 
//	provided at the time of installation or download, or which otherwise accompanies 
//	this software in either electronic or hard copy form.   

#pragma warning (disable : 4127) // conditional expression is constant
#pragma warning (disable : 4389) // signed/unsigned mismatch
#pragma warning (disable : 4714) // marked as __forceinline not inlined
#pragma warning (disable : 4244) // conversion ... possible loss of data
#pragma warning (disable : 4245) // signed/unsigned mismatch

#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>

#include <xsi_icenodecontext.h>
#include <xsi_icenodedef.h>
#include <xsi_command.h>
#include <xsi_factory.h>
#include <xsi_math.h>
#include <xsi_vector2f.h>
#include <xsi_vector3f.h>
#include <xsi_vector4f.h>
#include <xsi_matrix3f.h>
#include <xsi_matrix4f.h>
#include <xsi_rotationf.h>
#include <xsi_quaternionf.h>
#include <xsi_color4f.h>
#include <xsi_shape.h>
#include <xsi_indexset.h>
#include <xsi_dataarray.h>
#include <xsi_dataarray2D.h>

// Defines port, group and map identifiers used for registering the ICENode
enum IDs
{
	ID_IN_PointPositions = 0,
	ID_G_100 = 100,
	ID_OUT_MinPos = 200,
	ID_OUT_MaxPos = 201,
	ID_TMAP = 400,
	ID_SMAP,
	ID_CMAP,
	ID_UNDEF = ULONG_MAX
};

XSI::CStatus RegisterBBoxGenerator( XSI::PluginRegistrar& in_reg );

using namespace XSI; 
using namespace MATH; 

XSIPLUGINCALLBACK CStatus XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"Softimage");
	in_reg.PutName(L"BBoxGenerator Plugin");
	in_reg.PutEmail(L"");
	in_reg.PutURL(L"");
	in_reg.PutVersion(1,0);

	RegisterBBoxGenerator( in_reg );

	//RegistrationInsertionPoint - do not remove this line

	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
	CString strPluginName;
	strPluginName = in_reg.GetName();
	Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
	return CStatus::OK;
}

CStatus RegisterBBoxGenerator( PluginRegistrar& in_reg )
{
	ICENodeDef nodeDef;
	nodeDef = Application().GetFactory().CreateICENodeDef(L"BBoxGenerator", L"BBox Generator");

	CStatus st;
	st = nodeDef.PutThreadingModel(XSI::siICENodeSingleThreading);
	st.AssertSucceeded( ) ;

	// Add input ports and groups.
	st = nodeDef.AddPortGroup(ID_G_100);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(	ID_IN_PointPositions,
								ID_G_100,
								siICENodeDataVector3,
								siICENodeStructureSingle,
								siICENodeContextComponent0D,
								L"PointPositions", L"PointPositions",
								MATH::CVector3f(1.0,1.0,1.0),
								ID_UNDEF, ID_SMAP, ID_CMAP);

	st.AssertSucceeded( ) ;

	// Add output ports
	st = nodeDef.AddOutputPort(	ID_OUT_MinPos,
								siICENodeDataVector3,
								siICENodeStructureSingle,
								siICENodeContextSingleton,
								L"MinPos",L"MinPos");
	st.AssertSucceeded( ) ;

	st = nodeDef.AddOutputPort(	ID_OUT_MaxPos,
								siICENodeDataVector3,
								siICENodeStructureSingle,
								siICENodeContextSingleton,
								L"MaxPos",L"MaxPos");
	st.AssertSucceeded( ) ;

	PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
	nodeItem.PutCategories(L"Custom ICENode Sample");

	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus BBoxGenerator_Evaluate( ICENodeContext& in_ctxt )
{
	ULONG nPortID = in_ctxt.GetEvaluatedOutputPortID();
	switch ( nPortID )
	{
		case ID_OUT_MinPos:
		case ID_OUT_MaxPos:
		{
			Application xsi;

			// Just needed to force a frame by frame evaluation
			in_ctxt.SetAsTimeVarying( );
								
			CDataArrayVector3f posArray( in_ctxt, ID_IN_PointPositions );			
			CDataArrayVector3f outData( in_ctxt );
			
			// Iterate over all point positions of the geometry	to compute the min and max vectors
			CIndexSet indexSet( in_ctxt, ID_IN_PointPositions );
			CVector3f& v3f = posArray[ indexSet.Begin() ];			
			CVector3f v3fMin( v3f );
			CVector3f v3fMax( v3f );

			for ( CIndexSet::Iterator it = indexSet.Begin(); it.HasNext(); it.Next() )
			{
				v3f = posArray[ it ];

				if ( ID_OUT_MinPos == nPortID ) 
				{						
					if ( v3f.GetX() < v3fMin.GetX() ) v3fMin.PutX( v3f.GetX() );
					if ( v3f.GetY() < v3fMin.GetY() ) v3fMin.PutY( v3f.GetY() );					
					if ( v3f.GetZ() < v3fMin.GetZ() ) v3fMin.PutZ( v3f.GetZ() );
				}
				else
				{
					if ( v3f.GetX() > v3fMax.GetX() ) v3fMax.PutX( v3f.GetX() );
					if ( v3f.GetY() > v3fMax.GetY() ) v3fMax.PutY( v3f.GetY() );					
					if ( v3f.GetZ() > v3fMax.GetZ() ) v3fMax.PutZ( v3f.GetZ() );					
				}
			}
			
			// Output the min/max values
			if ( ID_OUT_MinPos == nPortID ) 
			{
				xsi.LogMessage( L"BBox Min: " + CString( v3fMin ) );
				outData[ 0 ] = v3fMin;
			}
			else
			{
				xsi.LogMessage( L"BBox Max: " + CString( v3fMax ) );
				outData[ 0 ] = v3fMax;
			}
		}
		break;		
	};
	return CStatus::OK;	
}