// CloudGeneratorFromDataFile Plugin
// Initial code generated by Softimage SDK Wizard
// Executed Sun Dec 13 11:42:55 EST 2009 by belzilm
// 
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>

#include <xsi_icenodecontext.h>
#include <xsi_icenodedef.h>
#include <xsi_command.h>
#include <xsi_factory.h>
#include <xsi_longarray.h>
#include <xsi_doublearray.h>
#include <xsi_math.h>
#include <xsi_vector2f.h>
#include <xsi_vector3f.h>
#include <xsi_vector4f.h>
#include <xsi_matrix3f.h>
#include <xsi_matrix4f.h>
#include <xsi_rotationf.h>
#include <xsi_quaternionf.h>
#include <xsi_color4f.h>
#include <xsi_shape.h>
#include <xsi_icegeometry.h>
#include <xsi_iceportstate.h>
#include <xsi_indexset.h>
#include <xsi_dataarray.h>
#include <xsi_dataarray2D.h>

#include "DataFileParser.h"

XSI::CStatus RegisterCloudGeneratorFromDataFile( XSI::PluginRegistrar& in_reg );

using namespace XSI; 

// Defines port, group and map identifiers used for registering the ICENode
enum IDs
{
	ID_IN_InFilePath = 0,
	ID_G_100 = 100,
	ID_OUT_OutPointPositions = 200,
	ID_TYPE_CNS = 400,
	ID_STRUCT_CNS,
	ID_CTXT_CNS,
	ID_UNDEF = ULONG_MAX
};

// The CloudGeneratorFromDataFile genererates the particle points as specified by the PointParticle attribute values saved in the 
// data file connected to the ID_IN_InFilePath port. The ID_IN_InFilePath port is connected to a 'File Path Sequence' node which 
// is always providing the proper data file based on the frame number being evaluated.
CStatus RegisterCloudGeneratorFromDataFile( PluginRegistrar& in_reg )
{
	ICENodeDef nodeDef;
	nodeDef = Application().GetFactory().CreateICENodeDef(L"CloudGeneratorFromDataFile",L"CloudGeneratorFromDataFile");

	CStatus st;
	st = nodeDef.PutColor(150,180,225);
	st.AssertSucceeded( ) ;

	// Add input ports and groups.
	st = nodeDef.AddPortGroup(ID_G_100);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_InFilePath,ID_G_100,siICENodeDataString,siICENodeStructureSingle,siICENodeContextSingleton,L"File Path",L"InFilePath",L"" );
	st.AssertSucceeded( ) ;

	// Add output ports.
	st = nodeDef.AddOutputPort(ID_OUT_OutPointPositions,siICENodeDataVector3,siICENodeStructureSingle,siICENodeContextElementGenerator,L"Points",L"OutPointPositions" );
	st.AssertSucceeded( ) ;

	PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
	nodeItem.PutCategories(L"Custom ICENode Sample");

	return CStatus::OK;
}

// Supported attribute
static CDataFileParser::TAttribPair attribPairs[] = 
{
	{ ID_OUT_OutPointPositions, "PointPosition" },
};

// The node use a file parser for reading the particle points. The parser is created when the node object 
// is created and released when the node is deleted. 
SICALLBACK CloudGeneratorFromDataFile_Init( CRef& in_ref )
{
	Context ctxt = in_ref;

	CDataFileParser* pParser = new CDataFileParser;
	ctxt.PutUserData( (CValue::siPtrType)pParser );

	// Tell the parser that we are only interested in the PointPosition attribute.	
	pParser->AddSupportedAttributes( attribPairs, 1 );
	
	return CStatus::OK;
}

// Time to release the file parser
SICALLBACK CloudGeneratorFromDataFile_Term( CRef& in_ref )
{
	Context ctxt = in_ref;
	CValue userData = ctxt.GetUserData( );
	if ( userData.IsEmpty() )
	{
		return CStatus::OK;
	}

	CDataFileParser* pParser = (CDataFileParser*)(CValue::siPtrType)ctxt.GetUserData( );
	if ( pParser )
	{
		delete pParser;
	}

	// Clear user data; 
	ctxt.PutUserData( CValue() );
	
	return CStatus::OK;
}

// Set the file parser at the beginning of each evaluation.
SICALLBACK CloudGeneratorFromDataFile_BeginEvaluate( ICENodeContext& in_ctxt )
{
	// Note: no need to force the evaluation at each frame as this is actually done by the FilePathSequence node.
	//in_ctxt.SetAsTimeVarying();
	
	// Open the file specified on input
	CDataArrayString InFilePathData( in_ctxt, ID_IN_InFilePath );
	CString strFilepath = InFilePathData[0];
	
	Application().LogMessage( CString("Opening data file: ") + strFilepath, siVerboseMsg );

	CValue userData = in_ctxt.GetUserData( );
	if ( userData.IsEmpty() )
	{
		// something's wrong
		return CStatus::False;
	}

	CDataFileParser* pParser = (CDataFileParser*)(CValue::siPtrType)in_ctxt.GetUserData( );
	if ( !pParser )
	{
		// something's wrong
		return CStatus::False;
	}
	
	// Set the parser for the point position attribute as specified in CloudGeneratorFromDataFile_Init
	ULONG nThreadCount = in_ctxt.GetEvaluationThreadCount();
	bool bRes = pParser->Init( strFilepath, nThreadCount );		
	if ( !bRes )
	{
		Application().LogMessage( CString("CloudGeneratorFromDataFile_BeginEvaluate: Couldn't initialize the data parser with file ") + strFilepath );
	}
		
	// Set the total number of elements to generate
	in_ctxt.PutNumberOfElementsToProcess( pParser->GetAttributeHandler(ID_OUT_OutPointPositions)->GetElementCount() );

	return CStatus::OK;
}

// Set the particle points for each element to generate with the values from the input data file.
SICALLBACK CloudGeneratorFromDataFile_Evaluate( ICENodeContext& in_ctxt )
{	
	// The current output port being evaluated...
	ULONG out_portID = in_ctxt.GetEvaluatedOutputPortID( );
  
	switch( out_portID )
	{		
		case ID_OUT_OutPointPositions :
		{
			CDataArrayVector3f outData( in_ctxt );
			CDataFileParser* pParser = (CDataFileParser*)(CValue::siPtrType)in_ctxt.GetUserData( );			
			CDataFileParser::AttributeHandler* pHandler = pParser->GetAttributeHandler( out_portID );			

			ULONG nThreadID = in_ctxt.GetCurrentThreadIndex();
			ULONG nDataOffset = pHandler->GetDataOffset();
			
			XSI::CIndexSet indexSet( in_ctxt );		
			for(XSI::CIndexSet::Iterator it = indexSet.Begin(); it.HasNext(); it.Next())
			{								
				ULONG nIndex = it.GetAbsoluteIndex();	
				pParser->GetData( nThreadID, nIndex, nDataOffset, outData[ it ] );
			}
		}
		break;		
	};
	
	return CStatus::OK;
}

// Done with the current evaluation, reset the file parser.
SICALLBACK CloudGeneratorFromDataFile_EndEvaluate( ICENodeContext& in_ctxt )
{
	// Close the file parser streams
	CValue userData = in_ctxt.GetUserData( );
	if ( userData.IsEmpty() )
	{
		return CStatus::OK;
	}

	CDataFileParser* pParser = (CDataFileParser*)(CValue::siPtrType)in_ctxt.GetUserData( );
	if ( pParser )
	{
		pParser->Term( );
	}
	
	return CStatus::OK;
}

