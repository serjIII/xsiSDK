// C++ Simple Undo Redo Command Plug-in. The plug-in demonstrates how to implement an undoable custom command.
//
// Initial code generated by Softimage SDK Wizard
// Executed Thu Oct 23 10:50:40 EDT 2008 by mbelzile
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
//
//	Copyright 2008 Autodesk, Inc.  All rights reserved.  
//	Use of this software is subject to the terms of the Autodesk license agreement 
//	provided at the time of installation or download, or which otherwise accompanies 
//	this software in either electronic or hard copy form.   

#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>
#include <xsi_argument.h>
#include <xsi_command.h>
#include <xsi_menu.h>
#include <xsi_layout.h>
#include <xsi_view.h>
#include <xsi_desktop.h>

#include <xsi_model.h>
#include <xsi_null.h>
using namespace XSI; 

// This class is used for implementing the undo/redo support for moving a view.
class CMoveViewTask
{
	public:
	struct Pos
	{
		LONG x;
		LONG y;
	};

	CMoveViewTask( const CString& in_strView, LONG x, LONG y, LONG origx=0, LONG origy=0 )
	{
		m_pos.x = x;
		m_pos.y = y;
		m_origpos.x = origx;
		m_origpos.y = origy;
		m_strView = in_strView;
	}

	void Do( )
	{
		Move( m_pos.x, m_pos.y );
	}

	void Undo( )
	{
		Move( m_origpos.x, m_origpos.y );
	}

	void Redo( )
	{
		Do( );
	}

	private:

	void Move( LONG x, LONG y )
	{
		Layout layout = Application().GetDesktop().GetActiveLayout();
		View v = layout.GetViews().GetItem( m_strView );
		v.Move( x, y );
	}

	Pos m_pos;
	Pos m_origpos;
	CString m_strView;
};

XSIPLUGINCALLBACK CStatus XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"Softimage Corp.");
	in_reg.PutName(L"C++ Simple Undo Redo Command Plug-in");
	in_reg.PutVersion(1,0);

	in_reg.RegisterCommand(L"SimpleUndoRedoCommand",L"SimpleUndoRedoCommand");
	in_reg.RegisterMenu(siMenuMainTopLevelID,L"Undoable Custom Command",false,false);
	//RegistrationInsertionPoint - do not remove this line

	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
	CString strPluginName;
	strPluginName = in_reg.GetName();
	Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus SimpleUndoRedoCommand_Init( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.EnableReturnValue(true);

	ArgumentArray args = oCmd.GetArguments();

	args.Add( L"view" );
	args.Add( L"x" );
	args.Add( L"y" );

	return CStatus::OK;
}

// This command moves a view at the x and y position speicified in arguments. The command demonstrates how undoing 
// custom action can be implemented using a helper undo class. The helper object is used to move the view and is 
// stored in Softimage. The helper object is passed to this command undo/redo callbacks when the Softimage undo or redo command 
// is fired for SimpleUndoRedoCommand.
XSIPLUGINCALLBACK CStatus SimpleUndoRedoCommand_Execute( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");

	bool bUndoRequired = ctxt.GetAttribute( L"UndoRequired" );

	if ( bUndoRequired )
	{
		// Undo is active so allocate an undo/redo helper object for this execution.
		Layout layout = Application().GetDesktop().GetActiveLayout();
		View v = layout.GetViews().GetItem( CString(args[0]) );

		// The task performs the action and save the data for undo redo.
		CMoveViewTask* pTask = new CMoveViewTask( args[0], args[1], args[2], v.GetAttributeValue( L"x" ), v.GetAttributeValue( L"y" ) );
		pTask->Do();

		// store the task in Softimage
		ctxt.PutAttribute( L"UndoRedoData", (CValue::siPtrType)pTask );
	}
	else
	{
		// No need to save undo data if undo is inactive i.e. the undo stack size is 0 or NewScene is called, etc...
		CMoveViewTask task( args[0], args[1], args[2] );

		task.Do();
	}

	// Return CStatus::Fail if you want to raise a script error
	return CStatus::OK;
}

// Called when the Softimage undo command is fired to undo SimpleUndoRedoCommand
XSIPLUGINCALLBACK CStatus SimpleUndoRedoCommand_Undo( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );

	CMoveViewTask* p = (CMoveViewTask*)(CValue::siPtrType)ctxt.GetAttribute(L"UndoRedoData");
	p->Undo( );

	return CStatus::OK;
}

// Called when the Softimage redo command is fired to redo SimpleUndoRedoCommand
XSIPLUGINCALLBACK CStatus SimpleUndoRedoCommand_Redo( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );

	CMoveViewTask* p = (CMoveViewTask*)(CValue::siPtrType)ctxt.GetAttribute(L"UndoRedoData");
	p->Redo( );

	return CStatus::OK;
}

// Called by Softimage when the SimpleUndoRedoCommand is no longer required for undo. This is typically used
// to release memory that might have been allocated in SimpleUndoRedoCommand_Execute
XSIPLUGINCALLBACK CStatus SimpleUndoRedoCommand_TermUndoRedo( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );

	CMoveViewTask* p = (CMoveViewTask*)(CValue::siPtrType)ctxt.GetAttribute(L"UndoRedoData");
	delete p;

	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus UndoableCustomCommand_Init( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Menu oMenu;
	oMenu = ctxt.GetSource();
	MenuItem oNewItem;
	oMenu.AddCallbackItem(L"Create Sample View", L"_OnCreateView",oNewItem);

	return CStatus::OK;
}


/// Create a netview object and call SimpleUndoRedoCommand to move the view as an undoable event.
XSIPLUGINCALLBACK XSI::CStatus _OnCreateView( XSI::CRef& in_ref )
{
	Context ctxt( in_ref );

	// Create and move new view
	Layout layout = Application().GetDesktop().GetActiveLayout();
	View view;
	layout.CreateView( L"Netview", L"Netview", view );
	view.Resize( 200, 300 );

	// Set original position
	LONG nPos = ctxt.GetUserData();
	view.Move( nPos, 100 );
	view.PutState( siNormal );	

	// Move view to new position with custom undoable command
	CValueArray args(3);
	args[0] = view.GetName();

	args[1] = nPos+200; // x
	args[2] = 300; // y

	// Save postion for the next view to be created by _OnCreateView
	ctxt.PutUserData( nPos+200 );

	CValue retval;
	Application().ExecuteCommand( L"SimpleUndoRedoCommand", args, retval );
	
	return CStatus::OK;
}

